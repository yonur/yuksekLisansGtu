LTC6804 Çoklu Batarya Görüntüleme Entegresi:
Seri Arayüzünün Genel Görünümü: 
LTC6804'te 2 tip seri portlar vardır, biri 4-hat seri çevrebirimi arayüzü (SPI), biri 2-hat izole arayüz(isoSPI)dir. 41 ve 
44 arasındaki pinler ISOMD pininin durumuna göre 2-hatlı yada 4-hatlı olarak konfigüre edilebilirler. LTC6804'ün 2 versiyonu
vardır: LTC6804-1 ve LTC6804-2. LTC6804-1 daisy-chain konfigürasyonda, LTC6804-2 ise adreslenebilir bus konfigürasyonunda 
kullanılmaktadır. LTC6804-2 45 ile 48 arasındaki pinleri V- yada VREG'e bağlayarak cihazın adresini set etmek için kullanmaktadır.

4-Hat SPI Fiziksel Katmanı:
Harici Bağlantılar: ISOMD'nin V-'ye bağlanması seri PORT A'yı 4-hat SPI için konfigğre eder. SDO, uygun bir kaynağa pullup direnci
ile bağlanması gereken bir open-drain çıkıştır.
Zamanlama: 4-hat seri port CPHA = 1 ve CPOL = 1 olarak kullanan bir SPI sistemi içerisinde çalışması için konfigüre edilmiştir.
Sonuç olarak, SDI üzerindeki data SCK'nın yükselen kenarı boyunca stabil kalmak zorundadır. Zmanalama veriföyünde şekil.15'te 
tasvir edilmiştir. Maksimum data rate 1Mbps'tir. 

2-Hat İzole Arayüz(isoSPI) Fiziksel Katmanı: 
2-hat arayüz LTC6804 cihazları basit twisted pair kablolama ile bağlamayı sağlamaktadır.
Arayüz RF frekansta kablolama yapıldığı durumlar için düşük paket hatası olacak şekilde tasarlanmıştır. İzolasyon harici bir trafo
ile elde edilmektedir.
Standart SPI sinyallleri diferansiyel pulselar içine gömülmüştür. Transmisyon pulse'ının dayanıklılığı ve alıcının threshold 
seviyesi harici iki direnç, RB1 ve RB2 tarafından teşkil edilmektedir.
Veriföyünde şekil 16'da isoSPI devresinin nasıl çalıştığı gösterilmiştir. 2V bir referans IBIAS pinini sürmektedir. Harici RB1 ve
RB2 dirençleri IB referans akımını oluşturmaktadır. Bu akım transmitter'in sürme gücünü belirlemektedir. RB1 ve RB2 aynı zamanda 
ICMP pininde 2V referans olacak şekilde gerilim bölücüsü olarak bir yapı sağlamaktadır. Bu yapı alıcı devrenin threshold gerilim 
seviyesini ayarlamaktadır. İletilen akım pulseları RM termination direnci(kablonun karakteritik empedansına paralel olacak şekilde)
tarafından voltaja dönüştürülmektedir. 
Harici Bağlantılar: LTC6804-1'nin PortA ve PortB olarak adlandırılan 2 adet seri portu vardır. PortB her zaman 2-hat arayüz(master)
olarak tasarlanmaktadır. PortB her zaman 2 hat arayüz olarak konfigüre edilmektedir(master). Daisy-chain'deki final cihaz bu portu 
kullanmaz, ve RM ile sonlandırılmalıdır(terminated).PortA ISOMD pininin bağlantısına göre ya 2-hat yada 4-hat arayüz(slave) olur.
Veri föyündeki şekil-17a'da her birinin birer LTC6804-1 içerdiği çoklu eşlenik PCB'lerin birbirleri ile dayanıklı bir bağlantı
yapısı oluşturmasına bir örnektir. Dasiy chain'deki son(final) cihazın sonlandırmasına dikkat ediniz. Mikroişlemci ayrı bir PCB'de 
yer alacaktır. Mikro işlemci PCB'si ile ilk LTC6804-1 PCB'si arasında 2-hat izolasyon sağlamak için LTC6820 IC'sini kullanınız.
LTC6820 veriföyündeki şekil-16'daki diyagram ile işlevsel olarak denktir.
LTC6804-2'nin ISOMD pinindeki duruma bağlı olarak 2-hat yada 4-hat olabilen tek bir single seri portu(Port A) vardır. 2-hat için 
konfigüre edildiğinde, veriföyündeki şekil-17b'de gösterildiği gibi konfigüre edildiğinde bir kaç cihaz multi-drop konfigürasyonda 
bağlanabilir. LTC6820 IC, MPU(master) ile LTC6804-2(slave) arasında arayüz olarak kullanilmaktadır.
Tek bir LTC6804'ün Kullanılması: Yalnızca bir tane LTC6804 kullanılacağı zaman, LTC6804-2 önerilmektedir. isoSPI portB olmaz, 
bundan dolayı daha az harici kompponente ihtiyaç duyar ve daha az enerji tüketir, özellikle PortA' nın 4-hat arayüz için 
konfigüre edildiği durumda. 
Buna rağmen, LTC6804-1, eğer ikinci isoSPI(port B) düzgün bir şekilde bayaslanır ve sonlandırılır ise şekil-18c'de görüldüğü gibi
single(non-daisy chained) kullanılabilir. ICMP GND ile bağlanmamalıdır, fakat direk olarak IBIAS ile bağlanabilir. 
Bir Bias direnci(2k ila 20k arasında) IBIAS için gereklidir. IBIAS'ı direk olarak VREG yada V-'ye bağlamayınız. Son olarak, IPB
ve IMB 100ohm bir direnç ile sonlandırılmalıdır(VREG yada V-'ye bağlanmamalıdır).
Bias Dirençlerin Seçimi: Ayarlanabilir sinyal genliği sisteme haberleşmenin sağlamlığı için güç tüketiminin takibi imkanını 
sağlamaktadır, ve ayarlanabilir komparator eşiği sistemin sinyal kayıplarını dikkate almasını sağlamaktadır. 
isoSPI transmitter IBIAS ve V- arasındaki gerilim bölücü(RBIAS = RB1 + RB2) ile eşiği belirlenen akım ve komparator voltajını 
sürmektedir. Bölünen gerilim(VICMP) komparator eşiğini bu gerilimin yarısına ayarlayan ICMP pinine bağlanmaktadır. isoSPI 
arayüzünün etkinleştirildiği(IDLE değil)nde IBIAS 2V'ta tutulduğu zaman, bir IB akımının IBIAS pininden dışarı akmasına sebep
olur. IP ve IM pinleri 20*IB bir akım sürmektedir.
Örnek olarak, RB1 direnci 2.8k ve RB2 direnci 1.21k ise (öyleyse RBIAS = 4k olur), böylece:
  IB = 2v / (RB1 + RB2) = 0.5mA
  IDRV = IIP = IIM = 20*IB = 10mA
  VICMP = 2V * (RB2 / (RB1 + RB2)) = IB * RB2 = 603mV
  VTCMP = 0.5*VICMP = 302mV
Bu örnekte, pulse sürme akımı IDRV 10mA olacaktır, alıcı komparatörü +/-302mV'tan dah büyük IP-IM genlikleri tespit edecktir.
Eğer izolasyon bariyeri twisted pair kablolar ile bağlı olan ve her bir ucunda 120ohm dirençlerle sonlandırılan 1:1 trafolar 
kullanmaktadır, ve bunun sonrasında iletilen diferansiyel sinyal genliği (+/-) şu şekilde olacaktır:
  VA = IDRV*RM/2 = 0.6V
(Bu sonuçta genliği azaltma ihtimali olan, trafo ve kablo kayıpları ihmal edilmiştir).

isoSPI pulse Detayları: İki LTC6804 cihaz diferansiyel pulsları izolasyon bariyeri boyunca ileri ve geri alarak ve göndererek 
haberleşmektedirler. Transmiter üç gerilim seviyesinde: +VA, 0V ve -VA çıkış verebilmektedir. Pozitif bir çıkış RM direnç yükü 
üzerinde IP sourcing akımı ve IM sinking akımı ile meydana gelmektedir. Negatif bir gerilim IP sinking ve IM sourcing ile 
meydana gelmektedir. Her iki çıkış off olduğu zaman, yük direnci diferansiyel çıkışı 0V'a inmesi için zorlamaktadır.
DC sinyal komponentlerini elemek ve güvenilirliği arttırmak için, isoSPI 2 farklı pulse uzunluğu kullanır. Bu tablo.21'de 
gösterildiği gibi 4 tip pulse'a izin vermektedir. A + 1 pulse negatif pulse'ı izleyen pozitif bir pulse olarak iletilecektir.
A - 1 pozitif pulse'ı izleyen negatif bir pulse olarak iletilecektir. Her bir pulse'ın uzunluğu t1/2PW olarak belirlenmiştir, 
çünkü her biri simetrik çiftin yarısı kadardır.(Toplam isoSPI süresi 2*t1/2PW kadardır).
Host mikrocontroller bu 2-hat arayüzü kullanmak için isoSPI pulselarını yaratmak zorunda değildir. Sistemdeki ilk LTC6804
mikrokontroller ile PortA'sı üzerinden 4-hat SPI arayüzünü kullanarak haberleşir, daha sonrasında diğer LTC6804'ler ile 
PortB'sini kullanarak 2-hat isoSPI arayüzü ile haberleşir. Alternatif olarak LTC6820 SPI sinyalleri isoSPI pulse'larına 
dönüştürmek için kullanılabilir.
LTC6804-1'in SPI için konfigüre edilen PortA ile Kullanılması:
LTC6804 PortA ile SPI'yı kulllandığı zaman(ISOMD = V-) dört adet haberleşme hadisesinden birini kullanır: CSB düşen, 
CSB yükselen, SDI = 0 iken SCK yükselen, ve SDI = 1 iken SCK yükselen. Her bir hadise LTC6804-1 daisy chain üzerinden iletimi 
için 4 pulse tipinden birine dönüştürülür. Uzun pulse'lar CSB değişiklikleri için kısa pulse'lar data iletimi için 
kullanılmaktadır, tablo-22'de gösterildiği üzere. İzolasyon barierin diğer tarafının üzerinde(örneğin kablonun diğer tarafında),
ikinci LTC6804'in ISOMD = VREG olacaktır. Onun PortA'sı slave isoSPI arayüzü olarak çalışacaktır. İletilen her bir pulse alacak
ve tablo.23'te görüldüğü gibi dahili olarak SPI sinyalini yeniden meydana getirecektir. Ek olarak, bir READ komutu boyunca bu 
port geri dönüş data pulse'larını belki iletebilir. Düşük isoSPI portu asla uzun(CSB) pulse'lar iletmez. Dahası, slave bir 
isoSPI port yalnızca kısa -1 pulse'ları iletir asla + iletemez. Master port bir null reponse'u lojik 1 olarak dikkate alır.  Bu
tek bir kablo üzerinde kolezyon(multidrop) riski olmadan pek çok slave cihaza imkan vermektedir.
Şekil-20'de daisy-chaine LTC6804-1 elemanının bir READ komutu için isoSPI zman diyagramı verilmiştir. ISOMD pini elemanın 
altkısmındaki   V-'ye bağlanmıştır bundan dolayı PortA'sı SPI port(CSB, SCK, SDI ve SDO) olarak konfigüre edilmiştir. 
Port(A ve B) parça numaraları ile isimlendirilerek üç bağlantılanmış cihazın isoSPI sinyalleri gösterilmiştir. Dikkat edilirse 
ki ISO B1 be ISO A2 aslında aynı sinyaldir, fakat part1 ve part2'yi bağlayan iletim kablosunun her bir ucunda gösterilmiştir.
Aynı şekilde, ISO B2 ve ISO A3 aynı sinyaldir, part 2 ve part 3 arasında kablo gecikmesi ile gösterilmiştir. Wn-W0 bitleri 16-bit
komut kodunu ve bir READ komutunun 16-bit PEC'ini temsil etmektedir. W0 bitinin sonunda 3 parça READ komutunu dekod eder ve SCK
clock'unun bir sonraki yükselen kenarında geçerli olan datayı dışarıya kaydırmaya başlar. Xn-X0 bitleri parça 1 tarafından 
dışarıya kaydırılan datayı temsil etmektedir. Yn-Y0 bitleri parça 3 tarafından dışarıya kaydırılan datayı temsil etmektedir. 
Zn-Z0 bilteri ise parça 3 tarafından dışarıya kaydırılan datayı temsil etmektedir.  Bütün bu data daisy-chained bir biçim 
içerisindeki parça 1'in SDO portundan geri okunur. 
Seri Arayüzü Uyandırmak: Seri portlar (SPI yada isoSPI) tIDLE süresi boyunca Port A üzerinde aktivite olmazsa, düşük güçlü IDLE
state'e geçmektedirler. WAKEUP devresi pin 41 ve 42 üzerindeki WAKEUP devresini görüntülemektedir.
Eğer ISOMD = V- ise, Port A SPI moddadır. CSB yada SCK pini üzerindeki aktivite SPI arayüzünü uyandıracaktır. Eğer ISOMD = VREG 
ise, Port A isoSPI moddadır. IPA-IMB üzerindeki diferansiyel aktivite isoSPI arayüzünü uyandırmaktadır. LTC6804, isoSPI durumu 
tWAKE yada tREADY, Core duruma bağlı olarak (Şekil-1 ve durum tanımlarına bakınız) süresi içerisinde READY durumuna döndüğü 
zaman haberleşme için hazır olacaktır. 
Şekil-21 zamanlama ve denklik devresinin fonksiyonalitesini göstermektedir. Ortak (common) mod sinyaller seri arayüzü 
uyandırmayacaktır. Arayüz uznu sinyal single-ended pulse, yada düşük-genlik simetrik puls aldıktan sonra uyanacak şekilde 
tasarlanmıştır. Diferansiyel sinyal |SCK(IPA) - CSB(IMA)|, seri ara yüzü enerjilendirecek uyandırma sinyali olarak 
nitelendirilebilmesi için en az tDWELL = 240ns süresince en azında VMAKE = 200mV seviyesinde olmalıdır.
Bir Daisy Chain'i Uyandırma - Method 1: LTC6804-1 haberleşmek için hazır olduktan sonra PortB üzerinde bir Long+1 pulse'ı 
göndermelidir. Bir daisy-chained konfigürasyonda, bu pulse yapıda bir sonraki cihazı uyandıracaktır, o da sırayla bir sonraki 
cihazı uyandıracaktır. Eğer yapıda N cihaz varsa, bütün cihazlar Core duruma bağlı olarak N*tWAKE yada N*tREADY sürede 
uyanacaktır. Büyük yapılar için N*tWAKE zamanı tIDLE'a eşit yada daha büyük olabilir. Bu durumda N*tWAKE süresinden daha uzun 
süre bekledikten sonra host belki başka bir dummy byte gönderir ve bütün cihazların READY durumunda olduğuna emin olmak için
N*tREADY süresince bekler. 
Method 1 daisy chain'deki tüm cihazlar IDLE durumdayken kullanılabilir. Bu uyandırma sinyalinin daisy-chain boyunca yayılmasını 
garantiler. Buna rağmen bu method daisy-chainin ortasındaki cihazlardan biri IDLE yerine READY durumunda olması halinde bütün cihazları 
uyandıramaz. Bu olduğu zaman, READY durumdaki cihaz uyandırma sinyalini yayamaz, bundan dolayı cihazlar IDLE durumda kalır. 
Bu durum yalznozca tIDLE kada zmaan sonra uyandırmaya uğraştığı takdirde gerçekleşebilir.
Bir Daisy Chain'i Uyandırma - Metohd 2: Daha sağlam bir uyandırma methodu yerleşik bir uyandıra methoduna bağlı değildir, fakat
manuel olarak bütün daisy-chaini uyandırmaya yetece süre kadar isoSPI trafiği gönderir. Her bir cihaz için en az bir çift uzun 
isoSPI pulse'lara (-1 ve +1) her bir cihaz için ihtiyaç duyulmaktadır, ayrıca tREADY yada tWAKE'den daha uzun daha fazla (eğer
core durum göreceli olarak STAMDBY yada SLEEP ise), fakat tIDLE'dan dah kısa süre. Bu her bir cihaza uyanması ve bir sonraki 
pulse'ı müteakip cihaza yaymasına imkan vermektedir. Bu method chain içerisindeki bazı cihazlar IDLE durumda olmasa dair çalışır.
Pratik olarak method 2'nin uygulanması uzun isoSPI pulse'larının yaratılması için CSB pininin toggle edilmesine (LTC6820'nin, 
yada ISOMD = 0 iken LTC6804-1'in altı) ihtiyaç duymaktadır. Alternatig olarak, dummy komutlar(örneğin RDCFG) uzun isoSPI 
pulse'larının  yaratılması için çalıştırılabilir.
Datalink Katmanı: LTC6804 üzerindeki bütün data trabsferleri byte grupları içerisinde meydana gelir. Her byte 8 bitten oluşur. 
Byte'lar MSB ilk iletilecek şekilde iletilir. CSB komut byte'ı ve sonraki data arasını içerecek şekilde komut seküensinin bütün
süresi boyunca low olarak kalmalıdır. Bir write komutu üzerinde, data CSB'nin yükselen kenarı üzerinde latch edilmelidir.
Network Katmanı: 
Paket Eror Kodu: Paket eror kodu (PEC) ilk PEC tohum değeri 000000000010000 ve x15 + x14 + x10 + x8 + x7 +
x4 + x3 + 1 karakteristik polinomunu kullanarak bir reister gruptaki gönderildiği sırada bütün bitler için hesaplanan bir 15-bit
cyclic redundancy kontrol değeridir.  15-bit PEC değerini hesaplamak için, basit bir prosedür belirlenmiştir:
1- PEC'i 000000000010000 ile ilklendir (PEC 15 bit bir register gruptur)
2- Her bir bit için PEC register gruba DIN gelmekte, ayarlanma şu şekildedir
  IN0  = DIN XOR PEC[14]
  IN3  = IN0 XOR PEC[2]
  IN4  = IN0 XOR PEC[3]
  IN7  = IN0 XOR PEC[6]
  IN8  = IN0 XOR PEC[7]
  IN10 = IN0 XOR PEC[9]
  IN14 = IN0 XOR PEC[13]
3- 15-bit PEC aşağıdaki gibi güncellenir
  PEC[14] = IN14,
  PEC [13] = PEC [12],
  PEC [12] = PEC [11],
  PEC [11] = PEC [10],
  PEC [10] = IN10,
  PEC [9] = PEC [8],
  PEC [8] = IN8,
  PEC [7] = IN7,
  PEC [6] = PEC [5],
  PEC [5] = PEC [4],
  PEC [4] = IN4,
  PEC [3] = IN3,
  PEC [2] = PEC [1],
  PEC [1] = PEC [0],
  PEC [0] = IN0
4- Bütün data shift edilene kadar step 2'ye geri dönün. Final PEC(16 bits) PEC register içerisindeki 15-bit değere LSB tarafın 0 
biti eklenmesi ile oluştırulur.
Şekil-22 yukarıda tanımlanan algoritmayı göstermektedir. PEC'in 16-bit word (0x0001) için hesaplanmasına dair bir örnek tablo-24
te verilmiştir. 0x001 için PEC LSB'sini 0 ile doldurduktan sonra 0x3D6E olarak hesaplanmaktadır. Daha uzun dta streamleri için,
PEC, PEC registerına gönderilen datanın son bitinin sonunda geçerlidir.
LTC6804 PEC'i alınan her hangi bir komut yada data için hesaplar ve onu müteakip komut yada datanın PEC'i ile karşılaştırır.
.......

Adress Komutları: Bir adres komutu bus üzerindeki sadece adreslenen cihazın cevap verdiği bir komuttur. Adres komutları yalnızca 
LTC6804-2 parçaları ile kullanılır. Bütün komutlar adresleme ile uyumludur. Adres komut formatı için bus protokollerine bakınız.
Broadcast Komutları(LTC6804-1 yada LTC6804-2): Bir broadcat komutu bus üzerindeki bütün cihazların adresine bakmaksızın cevap 
verdiği bir komuttur. Bu komut formatı LTC6804-1 ve LTC6804-2 için kullanılabşlmektedir. Broadcast komut formatı için Bus 
Protokollerine bakınız. Broadcast komutları ile bütün cihazlar komutları simültane olarak gönderebilmektedir.
Paralel konfigürasyonda (LTC6804-2), broadcast komutları ADC dönüşümleri ilklendirmek için yada bütün parçalara aynı data 
yazılıyor olduğunda yazma komutlarını göndermek için idealdir. polling fonksiyonu (ADC komutlarının sonunda otomatik, yada PLADC
komutnun manuel olarak kullanılması) broadcast komutları ile birlikte kullanılır, fakat sadece paralel SPI arayüzleri ile.
Polling paralel isoSPI ile uyumlu değildir.  Benzer şekilde, broadcast okuma komutları paralel konfigürasyonda kullanılmamalıdır
(ya SPI yada isoSPI).
Daisy-chained(LTC6804-1) konfigürasyonlar sadece broadcast komutları destekler, çünkü adreslemeleri yoktur. Chain'deki bütün 
cihazlar komut byte'larını simültane olarak alırlar. Örneğin, cihaz yığını içerisinde ADC dönüşümlerini ilklendirmek için 
tek bir ADCV komutu gnderilir, ve bütün cihazlar aynı anda dönüşüme başlar. Okuma ve yazma komutları için, tek bir komut 
gönderilir, ve müteakipen yığın cihazları yığında data her bir cihaz üzerinden bir sonraki cihaza  kaydırıldığı için 
efektif olarak kaskad shift register'a dönüştürülür. Seri programlama örneğine bakınız.
Polling Methodu: ADC'nin tamamlanması amacıyla mikrokontroller için tanımlanmış en basit methodADC dönüşümünü başlatıp sonucun
okunması için gerekli önceden belirlenmiş süre kadar beklenir. Polling daisy-chain haberleşmede desteklenmez(LTC6804-1).
Paralel konfigürasyonda SPI modda haberleşilir(ISOMD pin düşük seviyede bağlanır), iki polling methodu vardır. İlk method ADC 
dönüşüm komutunu gönderdikten sonra CSB'yi düşük tutmaktadır. Dönüşüm komutunu gönderdikten sonra, cihaz busy performe ederek 
dönüşüm yaparken SDO hattı düşük sürmektedir(Şekil 23). Cihaz dönüşümü tamamlandığı zaman SDO yüksek seviyede sürülür. Buna 
rağmen, dönüşüm tamamlanmamış olsa da CSB yüksek seviyede sürülürse SDO'da yükselecektir.Bu methodun problemi kontrölör ADC 
dönüşümün tamamlanmasını beklerken diğer işlerle uğraşamaz. 
Bir sonraki method ise bu sorunun üstesinden gelmektedir. Kontrolör bir ADC dönüşüm başlama komutu yollayabilir, diğer görevleri
icra edebilir, sonrasında ADC dönüşümlerinin durumunu öğrenmek için poll ADC dönüşüm durum(PLADC) komutunu yollar(şekil-24).
PLADC komutunu girdikten sonra eğer cihaz meşgul olarak dönüşüm durumu icra ediyorsa SDO düşük seviyeye geçecektir. Buna rağmen,
dönüşüm tamamlanmamış olsa da CSB yükseldiğinde SDO da yükselecektir. Paralel konfigürasyondaki cihazlarda PLADC komutunun nasıl
kullanıldığı programlama örneklerinde gösterilmiştir.
isoSPI modda haberleşen paralel konfigürasyonlarda düşük taraftaki port sadece alınan master isoSPI pulsına cevaben bir data
pulsı iletir. Bundan dolayı, yukarıda tanımlanan polling mmethodlarından biri için gönderilen adres komutunu müteakipen isoSPI data
palsı dönüşüm durumunu güncellemek için parçaya yollanır. Bu palslar LTC6820 kullanarak basit bir şekilde SCK pinini anahtarlamak için
gönderilebilir. Bu palsa cevaben eğer hala meşgul olarak dönüşüm icra ediliyorsa LTC6804-2 bir isoSPI palsı geri döndürür ve eğer 
dönüşüm tamamlandıysa bir pals geri döndürmez.  Eğer bir CSB yüksek SPI palsı LTC6804-2'ye gönderilirse polling komuttan çıkar.
Dikkat edilmelidir ki poll komutları paralel isoSPI ile uyumlu değildir.
Bus Protokolleri: 
Protokol Format: Tablo 27 ila 31 arasında broadcast komutları için protokol formatları gösterilmiştir. Tablo 26 protokol diyagramının 
okunması için anahtardır.
Komut Formatı: Sırasıyla tablo 32 ve tablo 33'te broadcast ve adres komutlarının formatları gösterilmiştir. 11-bit komut kodu
CC[10:0] broadcast yada adres komutu için aynıdır. Bütün komut kodlarının bir listesi tablo.34'te verilmiştir. Bir broadcast komutu
CMD0[7] ila CMD0[3] arası için bir 0 değerine sahiptir. Bir adres komutunun CMD0[7]'si birdir müteakip CMD0[6:3] arasındaki 4-bit ise
adrestir(a3,a2,a1,a0). Bir adreslenmiş cihazın A3 ila A0 pinleri arasındaki fiziksel adresi adres komutundaki adres ile eşleşir ise 
cihaz bu adres komutuna cevap verir. Broadcast ve adres komutlarının PEC'i bütün 16-bit komut (CMD0 ve CMD1) üzerinde hesaplanmaldır.
Komutlar: Tablo 34 LTC6804-1 ve LTC6804-2'nin her ikisi için bütün komutlar ve onların opsiyonlarını listelemiştir (CMD0 ve CMD1)
Programlama Örnekleri: Aşağıdaki örnekte S1,S2,S3 olarak isimlendirilmiş üç adet LTC6804-1 yığın olan bir konfigürasyon için müteakip
örnekler verilmiştir. S1 cihazı üzerindeki portA SPI modda konfigüre edilmiştir(ISOMD pini düşük seviye). S2 ve S3 cihazlarındaki 
port A isoSPI modda konfigüre edilmiştir(ISOMD pini düşük seviyede). S1 üzerindeki port B S2 üzerindeki port A'ya bağlanmıştır. S2
üzerindeki port B S3 üzerindeki port A'ya gidiyor. Mikrokontroller yığın ile S1 üzerindeki port A ile heberleşmektedir.
Seri Arayüzün Uyandırılması: 
1- Bir dummy byte gönderilir. CSB ve SCK üzerindeki aktivite  S1 üzerindeki seri arayüzü uyandıracaktır. 
2- S1, S2 ve S3 cihazlarının hepsini enerjilendirmek için 3*tWAKE süresi kadar beklenir.
Büyük yığınlarda cihazların bazıları uyandıktan sonra IDLE duruma geçebilir, adım 3 ve 4'ü uygulayınız:
3- İkinci dummy byte gönderilir
4- 3*tREADY süresince beklenir
5- Komutlar gönderilir.
Konfigürasyon Regiterlarına Yazma: 
1- CSB düşük seviyeye çekilir
2- WRCFG komutu (0x00 0x01) ve onun PEC (0x3D 0x6E) gönderilir
3- S3 cihazının CFGR0 byte'ı, daha sonrasında CFGR1(S3),...CFGR5(S3), CFGR0(S3) ten CFGR5(S3) e kadar olanların PEC değeri gönderilir.
4- S2 cihazının CFGR0 byte'ı, daha sonrasında CFGR1(S2),...CFGR5(S2), CFGR0(S2) ten CFGR5(S2) e kadar olanların PEC değeri gönderilir.
5- S1 cihazının CFGR0 byte'ı, daha sonrasında CFGR1(S1),...CFGR5(S2), CFGR0(S1) ten CFGR5(S1) e kadar olanların PEC değeri gönderilir.
6- CSB yüksek seviyeye çekilir, CSB'nin yükselen kenarında bütün cihazlarda data latch edilir.
Yukarıdaki seküens için seri ara yüz zamanının hesaplanması şu şekilde olur:
Daisy chain stack'i içierisndeki LTC6804-1'lerin sayısı = n
Seküens içerisindeki byteların sayısı(B):
Komut: 2 (Komut byte sayısı) + 2 (PEC byte sayısı) = 4
Data: Her bir LTC6804 için 6 (Data byte sayısı) + 2 (Data PEC byte sayısı) = her bir cihaz için 8 byte
B = 4 + 8*n
Her bir bit için seri port frekansı = F
Zaman = (1/F) * B * 8bit/byte = (1/F) * [4 + 8*n] * 8
Daha önce verilen 3 LTC6804'lü örnek için zaman, 1MHz seri port ile = (1/1e6)*(4+8*3) = 224uS
Not: Bu zaman bütün yazma ve okuma komutları için aynıdır.
Batarya hücresi Register Grup A'nın Okunması: 
1- CSB düşük seivyeye çekilir
2- RDCA komutu(0x00 0x04) ve onun PEC(0x07 0xC2) gönderilir
3- S1 cihazının CVAR0 byte'ı, sonrasında CVAR1(S1),...CVAR5(S1), CVAR0(S1) den CVAR5(S1)'e kadar olanların PEC'i okunur.
4- S2 cihazının CVAR0 byte'ı, sonrasında CVAR1(S2),...CVAR5(S1), CVAR0(S2) den CVAR5(S2)'e kadar olanların PEC'i okunur.
5- S3 cihazının CVAR0 byte'ı, sonrasında CVAR1(S3),...CVAR5(S3), CVAR0(S3) den CVAR5(S3)'e kadar olanların PEC'i okunur.
6- CSB yüksek seviyeye çekilir.
Batarya Hücresi Voltajı ADC Dönüşümüne Başlanması:
(Bütün hücreler, müsade edilen deşaj ile birlikte normal modda) ve poll durumunda
1- CSB düşük seviyeye çekilir
2- ADCV komutu MD[1:0] = 10 ve DCP = 1 v.b. 0x03 0x70 ve onun PEC(0xAF 0x42)i gönderilir.
3- CSB yükseğe çekilir
Batarya Hücresi Voltaj Registerlarının Temizlenmesi 
1- CSB düşük seviyeye çekilir
2- CLRCELL komutu (0x07 0x11) ve onun PEC(0xC9 0xC0) gönderilir
3- CSB yüksek seviyeye çekilir
ADC Durumunun Poll Edilmesi:
(Paralel konfigürasyon ve ISOMD = 0)
Bu örnek LTC6804-2'i A[3:0] = 0011 ve ISOMD = 0 ile adreslenmiş olarak kullanmaktadır.
1- CSB düşük seviyeye çekilir
2- PLADC komutu (0x9F 0x14) ve onun PEC(0x1C 0x48) gönderilir
3- SDO çıkışı eğer LTC6804-2 meşgul ise düşük seviyeye çekilir. Hostun adreslenmiş cihazdan polling durumunun güncellenebilmesi için
SCK'dan clock göndermesi gerekmektedir.
4- LTC6804-2 dönüşümü tamamladığında yüksek seviyede çıkışını vermesi gerekmektedir.
5- Polling'ten çıkılması için CSB yüksek seviyeye çekilmelidir.
LTC6804'e Bağlı Olan I2C Slave ile Konuşulması:
LTC6804 I2C slave cihazların GPIO4(SDA) ve GPIO5(SCL) pinlerine bağlanarak kullanılmasını desteklemektedir.
Şekil 25'de görüldüğü gibi bağlanarak küçük seri bir EEPROM'un içine ürün kalibrasyon sabitleri ve diğer bilgilerin depolanması
imkanı kayda değer bir kullanımdır.
Bu örnekte ...
LTC6804'e bağlanılan SPI Slave ile Konuşulması:...




